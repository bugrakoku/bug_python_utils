# -*- coding: utf-8 -*-
"""Images4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/141zdGTzDSNe6nrnsuZD5HXVASdNczrjp

#Image for search and image processing

Following functions are meant to generate patterns for basic object detection, identification and search
"""

import numpy as np
from skimage import io 
import random
import matplotlib.pyplot as plt

def Shapes(jpgNoise=False):
    '''
    This function generates a 640x480 color image by default
    Places shapes at random in this image with random colors
    Possible shapes are:
        circle
        ring (a circle with a circular hole)
        rectangle
        square
        frame (a rectangle with a rectangular hole)
    if jpgNoise is False, no noise will be added, if True
    quality will be used, the lower the quality towards 1, to harder the problem will be
    '''
    imSize = [480, 640]
    Imquality = 25
    #a minimum image size of 300 is assumed
    '''
    minsize = 300
    if imSize[0] < minsize:
        imSize[0] = minsize
    if imSize[1] < minsize:
        imSize[1] = minsize
    
    # impose bounds on quality if it will be used
    if jpgNoise:
        if Imquality < 1:
            Imquality = 1
        elif Imquality > 95:
            Imquality = 95
    '''

    def newShapeOK(lShapes,shape):
        '''
        returns true if the passed shape is not overlapping with existing ones
        shape is: ((y0,x0), (y1,x1)) points corresponding to upper lwft and lower right corners of the bounding box
        '''
        if len(lShapes) == 0:
            return True # this is the first shape
        # candidate coordinates
        cy0, cx0, cy1, cx1 = shape[0][0], shape[0][1], shape[1][0],shape[1][1]
        safeband = 5
        for s in lShapes:
            sy0, sx0, sy1, sx1 = s[0][0][0], s[0][0][1], s[0][1][0],s[0][1][1]
            if (cy0 >= (sy0-safeband) and cy0<= (sy1 + safeband)) or \
            (cy1 >= (sy0-safeband) and cy1<= (sy1 + safeband)) or \
            (cx0 >= (sx0 - safeband) and cx0<= (sx1+safeband)) or \
            (cx1 >= (sx0-safeband) and cx1<= (sx1+safeband)):
                return False
            if (sy0 >= (cy0-safeband) and sy0<= (cy1 + safeband)) or \
            (sy1 >= (cy0-safeband) and sy1<= (cy1 + safeband)) or \
            (sx0 >= (cx0 - safeband) and sx0<= (cx1+safeband)) or \
            (sx1 >= (cx0-safeband) and sx1<= (cx1+safeband)):
                return False

        return True


    def create_circular_mask(h=480, w=640, bbox=None):
        '''
        as implied by the name
        downloaded from: https://newbedev.com/how-can-i-create-a-circular-mask-for-a-numpy-array
        modified to return binary images
        and accept a bounding box for the circle  ((y0,x0),(y1,x1))
        bbox is supposed to be properly set, no stupidity checks
        '''
        if bbox is None:
            bbox = ((1,1),(h,w)) # use almost the whole image
        radius = (bbox[1][1]-bbox[0][1])/2 # assume circle
        # get center
        center = (bbox[0][1] + (bbox[1][1]-bbox[0][1])/2, 
                  bbox[0][0] + (bbox[1][0]-bbox[0][0])/2)
        '''
        if center is None: # use the middle of the image
            center = (int(w/2), int(h/2))
        if radius is None: # use the smallest distance between the center and image walls
            radius = min(center[0], center[1], w-center[0], h-center[1])
        '''
        Y, X = np.ogrid[:h, :w]
        dist_from_center = np.sqrt((X - center[0])**2 + (Y-center[1])**2)

        mask = dist_from_center <= radius
        cirmask = np.zeros_like(mask, dtype=np.uint8) # generate a binary image mask with black 0, white 255
        cirmask[np.where(mask==True)] = 255
        return cirmask

    def randomColor():
        colorz = ((255,0,0),
        		(0,255,0),
        		(0,0,255),
        		(255,255,0),
        		(255,0,255),
        		(0,255,255))
        return random.choice(colorz)

    randrange = (20,30) # how many shapes will be generated
    aspectRatio = (1.4, 2.2) # aspect ratio range for rectangles and frames
    numTries = 1000 # try so many times before you decide you cannot fit the shape
    # define shape generateion parameters
    shapes = {'circle':((25,50),),
              'ring':((25,50),(5,8)),
              'rectangle':((20,50),(1.5,2.5)),
              'square':((25,50),),
              'frame':((20,50),(5,9))}

    # generate empty mask and color image
    mask = np.zeros(imSize, dtype=np.uint8)
    colorIm = np.zeros((*imSize,3))

    # generate shape parameters
    allShapes = [] # keep track of coordinates and shape types
    nShapes = np.random.randint(randrange[0], randrange[1])
    #print(f'trying to get {nShapes} shapes')

    for i in range(nShapes):
        # select a random shape
        shapeKey = list(shapes.keys())[np.random.randint(0,len(shapes.keys()))]
        # set width and height of the 
        if shapeKey == 'circle' or shapeKey == 'ring' or shapeKey == 'square':
            w = np.random.randint(shapes[shapeKey][0][0], shapes[shapeKey][0][1])
            h = w
        else: # assume frame or rectangle
            w = np.random.randint(shapes[shapeKey][0][0], shapes[shapeKey][0][1])
            h = int(w * np.random.uniform(*aspectRatio))
            if np.random.randint(0,10) >=5: # 50-50 rotate rectangle
                w,h = h,w
        #print(f'a {shapeKey} with w={w} and h={h}')

        # try to fit this shape into the current scene by randomly locating it
        for t in range(numTries):
            # come up with a random location
            y = np.random.randint(h+1, imSize[0]-h-1)
            x = np.random.randint(w+1, imSize[1]-w-1)
            # generate coordiantes
            maybeShape = ((y,x),(y+h,x+w))
            # check if it is OK
            if newShapeOK(allShapes, maybeShape): # cool
                allShapes.append((maybeShape, shapeKey)) # (coordiantes, shapeID) are added to the list
                # register shape to the mask
                if shapeKey == 'square' or shapeKey == 'rectangle':
                    cMask = np.zeros_like(mask, dtype=np.uint8)
                    cMask[maybeShape[0][0]: maybeShape[1][0], maybeShape[0][1]: maybeShape[1][1]] = 255
                    #goodones = np.where(cMask == 255)
                    #mask[goodones] = 255
                    #colorIm[goodones[0], goodones[1],:] = randomColor()

                elif shapeKey == 'frame':

                    cMask = np.zeros_like(mask, dtype=np.uint8)
                    cMask[maybeShape[0][0]: maybeShape[1][0], maybeShape[0][1]: maybeShape[1][1]] = 255
                    frameT = np.random.randint(shapes['frame'][1][0], shapes['frame'][1][1])
                    fy0, fx0 = maybeShape[0][0] + frameT, maybeShape[0][1] + frameT
                    fy1, fx1 = maybeShape[1][0] - frameT, maybeShape[1][1] - frameT
                    emptyShape = ((fy0, fx0),(fy1, fx1))
                    cMask[emptyShape[0][0]: emptyShape[1][0], emptyShape[0][1]: emptyShape[1][1]] = 0
                    #goodones = np.where(cMask == 255)
                    #mask[goodones] = 255
                    #colorIm[goodones[0], goodones[1],:] = randomColor()
                    #mask[np.where(cMask == 255)] = 255

                elif shapeKey == 'circle':
                    cMask = create_circular_mask(bbox=maybeShape)
                    #mask[np.where(cMask == 255)] = 255

                elif shapeKey == 'ring':
                    cMask = create_circular_mask(bbox=maybeShape)
                    frameT = np.random.randint(shapes['ring'][1][0], shapes['ring'][1][1])
                    fy0, fx0 = maybeShape[0][0] + frameT, maybeShape[0][1] + frameT
                    fy1, fx1 = maybeShape[1][0] - frameT, maybeShape[1][1] - frameT
                    emptyShape = ((fy0, fx0),(fy1, fx1))
                    cMask2 = create_circular_mask(bbox=emptyShape)
                    cMask -= cMask2
                    #mask[np.where(cMask == 255)] = 255
                #finally update mask
                goodones = np.where(cMask == 255)
                mask[goodones] = 255
                colorIm[goodones[0], goodones[1],:] = randomColor()

                #print(f'{shapeKey} located at {maybeShape}')
                # 
                break
        if jpgNoise:
            io.imsave('test.jpg', colorIm, quality = Imquality)
            colorIm = io.imread('test.jpg')


    return colorIm, allShapes

def aMaze():
    '''
    returns a different kind of a maze compozed of colored boxes with corridors in between
    each color has a different difficulty level (or simply cost)
    objective will be to find the cheapest solution from a GREEN box to a RED box, center to center
    BLACK pixels are walls, solutions cannot pass through any BLACK pixel
    the function returns a color image where all colors other than RED, GREEN and BLACK 
    are returned in a dictionary which expalains which color costs how much
    An entry in the dictionary looks like:
        ((c1,c2,c3),cost_value)
    where ci are color values for RGB
    
    '''
    colorz = (
            (255,255,255),
            (0,0,150),
            (150,150,0),
            (150,0,150),
            (0,150,150),
            (222,55,222),
            (0, 99, 55),
            (0,0,0))
    GREEN = (0,255,0)
    RED = (255,0,0)

    # maze parameters
    imSize = 500
    nCorr = 8
    boxSize = 50
    # derived variables
    step_size = int(imSize/nCorr) # dist between rows and columns of boxes
    hw = int(boxSize / 2) # half of a box not really need but anyway

    cmask = np.ones((imSize,imSize,3), dtype=np.uint8) * 255 # mask is white

    for i in range(1,nCorr):
        for j  in range(1,nCorr):
            # put a black box around (i,j)
            cmask[i*step_size-hw:i*step_size+hw,
                  j*step_size-hw:j*step_size+hw,:] = random.choice(colorz[1:]) 
    # colored mask is generated, next generate the start and end boxes
    si, sj = np.random.randint(1,int(nCorr/2)), np.random.randint(1,int(nCorr/2))
    ei, ej = np.random.randint(int(nCorr/2),nCorr), np.random.randint(int(nCorr/2),nCorr)
    # 
    cmask[si*step_size-hw:si*step_size+hw,
          sj*step_size-hw:sj*step_size+hw,:] = RED
    cmask[ei*step_size-hw:ei*step_size+hw,
          ej*step_size-hw:ej*step_size+hw,:] = GREEN
    # now return the dictionary of colors and random cost values
    valz = {}
    costs = [2*x for x in range(1,len(colorz))]
    random.shuffle(costs)
    for i, clr in enumerate(colorz[:-1]):
        valz[f'color_{i+1}'] =(clr, costs[i]) 

    return cmask, valz
